33번 문제

1. 각각 입력받은 lottos 의 배열과 win_nums 배열중 일치하는 개 몇개 인지 체크 (카운트를 할지 length 할지는 나중에 다시생각해보기)

2. 비교후 나온 일치갯수가 최소 0에서 최대 6개 인것을 count에 넣어줌. 그리고 count된 갯수와 등수가 대응되게 만드는 메서드를 찾아볼것 ex. 6개 ->[6,5,4,3,2,1] 중 인덱스 5에 해당,

5개 -> 인덱스 4에 해당, …1개일때 와 0개일때 인덱스 0해당. 설정 해줄 배열 만듬 즉. Rank = [6,5,4,3,2,1] 을 설정해줌.

3. 아까 하지않았던 최소 맞은갯수를 최저등수로 잡고, 최고 등수를 구하기위해서 현재 0(가려진값)이 몇개 있는지 찾아서 그 갯수와 최서등수일때 갖았던 값과 더한다   
   ex 2개를 맞은 lottos에 0이 1개 있다면 2+1 =3 이런식으로. 
   그럼 최소 2개 는 Rank인덱스 1와 매치되어 5등이됨, 최대는 3개 이므로 rank 인덱스 2에 해당하므로 4등이 된다

---------------------------

1. includes(), reduce()의 current 와 acc 을 비교 후 cnt 증가, filter 사용 대응되는 값 가져온 배열을 .length 사용. 
    1.1) includes 를 사용하면 lottos.includes(win_nums) 라고 사용하는것 같다. 이떄 만약 includes 한게 있다면? 어떻게 가져오지?
    return 값이 포함하면 true 아니면 false 인데 이때 true일때만 만족하는 조건문을 넣고 그 true 를가진 값을 a에 push 그리고 if 문을 들어갈때마다 cnt++








    

    ----------------------------

    27번 콜라츠 추측

    1이미 알고리즘은 주어졌기때문에 그대로 적용만 하면된다. 처음 반복문을 나올 조건은 입력값 a 가 1 이 될때 break 하는것이다. 따라서 while(1) 무한 반복하다가, 
    if a===1 일때 break; 해준다.
    2. 어떤걸 반복할지 정해야하는데 이때 if문을 이용하여 나눈 나머지를 홀수 짝수 를 나누고 짝수면 초기 입력값을 /2로 나누게 해주고, 입력값이 홀수면 *3한후 +1 해줌
    3. if문을 통과할때마다 count++ 을 해주어서 몇번의 반복문을 실행할지 정해줌
    4. count가 500초과 하면 즉 501 부터는 -1 을 리턴하게 해줌
    ---------------------------



    최소 직사각형

    가로 세로중 가장 큰 수를 기준으로 잡고

    그 명함의 최대길이를 뺸 가로나 세로 길이를 나머지 명함들의 가로,세로 와 비교를 한다, 이때 각 명함들의 최소값인 것을 비교하여 최대 길이를 가진 명함보다 다른 명함의 최소값이 크다면 
    그 길이만 다른 명함에서 교체한다. 

    배열의 각 인덱스의 값을 비교
    for (var i =0, i<2 ;i ++)
    {

    }